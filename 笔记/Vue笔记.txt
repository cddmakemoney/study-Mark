CDN引用：<script src="https://cdn.staticfile.org/vue/2.4.2/vue.min.js"></script>

vue的几个规则：

vue不允许子组件修改父组件数据，以免数据改动的来源不明
子组件通过this.$emit('update:title', newTitle)触发事件（事件发布）
父组件监听子组件并通过$event获取'new Title'，根据需要更新数据（事件订阅）


style标签中scoped属性的功能：<style scoped >
实现组件的私有化，不对全局造成样式污染，表示当前style属性只属于当前模块

一个小插件：
nanoid，生成唯一的ID，
安装：npm i nanoid
使用：import { nanoid } from "nanoid";
	接着nanoid()





 Vue 构造器中有一个el 参数，它是 DOM 元素中的 id。所以在script中new了VUE，要把它的el参数和在body中想要写的div id相符合

当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。
当这些属性的值发生改变时，html 视图将也会产生相应的变化。


 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可：
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>


Vue 实例还提供了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来：
var vm = new Vue({				//意思就是$el、$data这些，是属于vue框架本身有的属性，不是用户说有才有的
		el: '#vue_det',
		data: ...
})


Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由"管道符"指示
{{data|methods}}，也可以再添加methods，用	|	间隔。添加之后它们之间的执行顺序是从左到右的：
基本格式：
<div id="app">
  {{ message | capitalize }}
</div>

new Vue({
  el: '#app',
  data: {
    message: 'runoob'
  },
  filters: {
    capitalize: function (value) {
      if (!value) return '';
      value = value.toString();
      return value.charAt(0).toUpperCase() + value.slice(1);
    }
  }
})





@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建【双向数据绑定】，
根据表单上的值，自动更新绑定的元素的值。
【v-model修饰符】：
	一、.lazy：      在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，
		       从而转变为在 change 事件中同步：
	<input v-model.lazy="msg" >	//效果为等输入完毕后点击其他地方才会更新

	二、.number：当你需要用数据作运算的时候，要把他转化为为number类型，因为v-model默认是string类型：
	<input v-model.number="age" type="number">

	三、.trim：      如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：
	<input v-model.trim="msg">



v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

text 和 textarea 元素使用 value property 和 input 事件；
checkbox 和 radio 使用 checked property 和 change 事件；
select 字段将 value 作为 prop 并将 change 作为事件。



复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组：
<input type="checkbox" id="runoob" value="Runoob" v-model="checkedNames">
data: {
    checkedNames: []
  }

V-bind则是【属性绑定】：v-bind：属性名=表达式
<div v-bind:class=	"{ 	active	   ：	isActive	 }"	></div>	//意思是用不用    .active   这个类，取决于isActive这个值
v-bind:class="{ 'active' : isActive, 'text-danger' : hasError }"  	//可以绑多种
<div v-bind:class="[activeClass, errorClass]"></div>         	//可以传数组形式
new Vue({
  el: '#app',
  data: {
    activeClass: 'active',		//通常直接将样式写在一个对象里面，再把对象名写到上面数组里面
    errorClass: 'text-danger'
  }

<div v-bind:class="[errorClass ,isActive ? activeClass : '']"></div>	//意思是使用data属性：errorClass里面的类，
							并且写了一个三元表达式来确定另一个要用的类


绑定样式时：v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。
CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：

<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>	//   也可以  'font-size': fontSize + 'px'
data: {
  activeColor: 'red',
  fontSize: 30
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@




v-text指令的作用：设置标签的内容，会替换全部内容:
 <h2 v-text="message">北海</h2>  	//北海两个字不会显示出来

v-if直接操作DOM元素，原理是从DOM树中移除。v-show操作的是display。所以频繁操作用show，反之用if。因为操作DOM元素对性能的消耗比较大
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。
因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。

v-bind 缩写：
<!-- 完整语法 -->
<a v-bind:href="url"></a>
<!-- 缩写 -->
<a :href="url"></a>

v-on 缩写：
<!-- 完整语法 -->
<a v-on:click="doSomething"></a>
<!-- 缩写 -->
<a @click="doSomething"></a>

		【V-for必须要有key】						
v-for 指令需要以 	别名 in 对象或数组	 形式的特殊语法， “对象或数组”是源数据数组并且 “别名” 是数组元素迭代的别名。
（意思就是in前面的命名随便取，它只是个工具人）
你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法
数组方法：
push()
pop()
shift()
unshift()
splice()
sort()
reverse()

 
迭代【对象】：
v-for 可以通过一个对象的属性来迭代数据【键值】：v-for="value in object"
也可以提供第二个的参数为【键名】：v-for="(value, key) in object"
第三个参数为索引【下标】：v-for="(value, key, index) in object"

迭代【数组】：第一个参数为值，第二个为下标，没有第三个参数

我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，
只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。

computed 属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：
 var vm = new Vue({
  data: { a: 1 },

  computed: {
    // 仅读取
    aDouble: function () {
      return this.a * 2
    },

    // 读取和设置
    aPlus: {
      get: function () {		//get和set的名字是固定的，不是随便定义的
        return this.a + 1
      },
      set: function (v) {
        this.a = v - 1
      }
    }
  }
})
vm.aPlus   // => 2
vm.aPlus = 3
vm.a       // => 2
vm.aDouble // => 4


Vue.js 监听属性 watch，我们可以通过 watch 来响应数据的变化。
不应该使用箭头函数来定义 watcher 函数
理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例
 基本格式：watch: {
	//如果a改变了，那么就会执行这个函数
 	   a: function (Val, oldVal) {
     	。。。
   	 },
vm.$watch('要监视的属性', function (newVal, oldVal) {		//实例方法也能监视
	
  // 做点什么


watch:{					//监视keyWord:这个属性
					keyWord:{
						immediate:true,  //深度监视
						handler(val){   //这个函数名字是固定的，表示监视的属性更改之后要做的步骤
							this.filPerons = this.persons.filter((p)=>{
								return p.name.indexOf(val) !== -1
							})
						}
					}
				}


})
		【监视能完成异步操作，计算属性不能；计算属性能完成的，监视都能完成，反之不一定 】

收集表单数据：
		若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。
		若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。
		若：<input type="checkbox"/>
			1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）
			2.配置input的value属性:
					(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
					(2)v-model的初始值是数组，那么收集的的就是value组成的数组





【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】
				这部分最好直接看官方文档
				组件里的this都是VC（Vuecompone）
			       一个组件的 data 选项必须是一个函数：

data: function () {
  return {
    count: 0
  }
}


组件：
全局的基本格式：
<div id="app">
    <runoob></runoob>
</div>
 
<script>
// 注册
Vue.component('runoob', {
  template: '<h1>自定义组件!</h1>'
})
// 创建根实例
new Vue({
  el: '#app'
})
</script>



prop 是子组件用来接受父组件传递过来的数据的一个自定义属性。
props: ['message']
 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。
如果像这样设置了props，那么父组件的数据需要通过 props 把数据传给子组件。

	<child message="hello!"></child>
  或者：	<child v-bind:message="parentMsg"></child>	//parentMsg是data里的数据

Vue.component('child', {
  // 声明 props
  props: ['message'],
  // 同样也可以在 vm 实例中像 "this.message" 这样使用
  template: '<span>{{ message }}</span>'
})


通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：
props: {
  title: String,		//  随便命名：类型
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}



父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件！
vm.$emit( 'event', arg )	【注意事件名要单引号或者双引号】
$emit 绑定一个自定义事件event，当这个这个语句被执行到的时候，就会将参数arg传递给父组件，父组件通过@event监听并接收参数。

注意局部注册的组件在其子组件中不可用。例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写：

var ComponentA = { /* ... */ }

var ComponentB = {
  components: {
    'component-a': ComponentA
  },
  // ...
}


【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】【】

父元素里有子元素，如果点击了子元素, 那么click 事件不仅会发生在子元素上，也会发生在其父元素上，依次不停地向父元素冒泡
事件修饰符 ：
阻止冒泡：.stop	：<div id="me" v-on:click.stop="doc">
优先触发 .capture	<div id="father" v-on:click.capture="doc">
		当冒泡发生的时候，就会优先让father捕捉事件。
无法被触发： .self 	<div id="father" v-on:click.self="doc">
只触发一次：.once	<div id="father" v-on:click.once="doc">

vue中的.sync修饰符用法及原理详解:
https://blog.csdn.net/liushijun_/article/details/92426854



指令：


v-pre：跳过这个元素和它的子元素的编译过程。跳过大量没有指令的节点会加快编译。
<span v-pre>{{ this will not be compiled }}</span>

v-once：只渲染元素和组件一次。只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。
这可以用于优化更新性能。
<span v-once>This will never change: {{msg}}</span>


自定义指令：
指令钩子函数：
bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。

钩子函数参数：
el：指令所绑定的元素，可以用来直接操作 DOM。
binding：一个对象，包含以下 property：
	name：指令名，不包括 v- 前缀。
	value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
	oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
	arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。

		注意：不是一定要使用它给的钩子函数，可以直接 function（）{ }

【创建全局指令】：
需要传入指令名称以及一个包含指令钩子函数的对象，该对象的键即钩子函数的函数名，值即函数体，钩子函数可以有多个：
Vue.directive('self_defined_name',{
  bind:function(el,binding){
  //do someting
  },
  inserted: function(el,binding){
  //do something
  },
}


【创建局部指令】：
直接向创建的 Vue 实例的 directives 字典属性添加键值对，键值对即需要添加的自定义指令及对应钩子函数字典对象。
键值对可以有多个，对应多个自定义指令：
new Vue({
  el:'#app',
  directives:{
    self_defined_name1:{
        bind:function(el,binding){
          //do something
        }
        inserted:function(el,binding){
                  //do something
        },
     }

    self_defined_name2:{
        bind:function(el,binding){
          //do something
        }
        inserted:function(el,binding){
                  //do something
        },
     }
  }

})  








混入：	就是多个组件合起来
var mixin = {
    created: function () {
        document.write('混入调用' + '<br>')
    }
}
new Vue({
    mixins: [mixin],
        created: function () {
        document.write('组件调用' + '<br>')
    }
});
	//输出：   混入调用
		组件调用

混入对象的钩子将在组件自身钩子之前调用。
数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。
如果 methods 选项中有相同的函数名，则 Vue 实例优先级会较高

vm.$options：
用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处：
new Vue({
            mixins: [mixin],
            cdd:'ddd',
            data:{
                cdd:'ddg'
            },
            created: function () {
                document.write('组件调用' + this.$options.cdd)	//输出ddd； this.cdd则输出ddg
            }
        });








